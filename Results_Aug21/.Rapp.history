is.numeric(d[,2])
is.numeric(d[,1:10])
is.numeric(d[,3])
is.numeric(d[,4])
is.numeric(d[,5])
nums <- sapply(d, is.numeric)
nums
nums==TRUE
which(nums==TRUE)
subs<-which(nums==TRUE)
head(d[,subs])
blocks <-aggregate(D, by=list(MZ), na.rm=TRUE)
blocks <-aggregate(D, by=list(MZ), fun=sum,na.rm=TRUE)
D
subs<-which(nums==TRUE)#
dd<-d[,subs]#
blocks <-aggregate(dd, by=list(MZ), fun=sum,na.rm=TRUE)
blocks <-aggregate(dd, by=list(MZ), FUN=sum,na.rm=TRUE)
names(dd)
blocks <-aggregate(dd, by=list("MZ"), FUN=sum,na.rm=TRUE)
dd$MZ
blocks <-aggregate(dd, by=list(dd$MZ), FUN=sum,na.rm=TRUE)
head(blocks)
blocks <-aggregate(dd, by=list(dd$L,dd$MZ), FUN=sum,na.rm=TRUE)
head(blocks)
edit(blocks)
blocks <-aggregate(dd, by=list(dd$L,dd$MZ), FUN=mean,na.rm=TRUE)
edit(blocks)
nums <- sapply(d, is.numeric)#
subs<-which(nums==TRUE)#
dd<-d[,subs]#
blocks <-aggregate(dd, by=list(dd$L,dd$MZ), FUN=mean,na.rm=TRUE)
edit(blocks)
blocks <-aggregate(dd, by=list(dd$MZ,dd$L), FUN=mean,na.rm=TRUE)
edit(block)
edit(blocks)
blocks <-aggregate(dd, by=list(dd$MZ,dd$L), FUN=sum,na.rm=TRUE)
edit(blocks)
dd<-d[,subs]#
dd$count<-1
head(dd)
blocks <-aggregate(dd, by=list(dd$MZ,dd$L), FUN=sum,na.rm=TRUE)
names(block)
names(blocks)
names(blocks)[1]<-"MZ"
names(blocks)
names(blocks)names(blocks)[1]<-"MZ"#
names(blocks)[2]<-"LOC"
names(blocks)[1]<-"MZ"#
names(blocks)[2]<-"LOC"
names(blocks)
names(blocks)[1]<-"MANZANA"#
names(blocks)[2]<-"LOC"#
blocks<-blocks[-MZ]
names(blocks)[1]<-"MANZANA"#
names(blocks)[2]<-"LOC"#
blocks<-blocks[,-MZ]
names(blocks)
names(blocks)[1]<-"MANZANA"#
names(blocks)[2]<-"LOC"#
blocks<-blocks[,-"MZ"]
blocks <-aggregate(dd, by=list(dd$MZ,dd$L), FUN=sum,na.rm=TRUE)#
names(blocks)[1]<-"MANZANA"#
names(blocks)[2]<-"LOC"
edit(blocks)
head(blokcs)
head(blocks)
?aggregate
install.packages("data.table")#
library(data.table)
DT <- data.table(d)
head(DT)
names(DT)
head(dd)
library(data.table)#
DT <- data.table(dd)#
DT[, list(INF = sum(count), L = mean(L)), by = MZ]
library(data.table)#
DT <- data.table(dd)#
DT[, list(INF = sum(count), L = mean(L)), by=list(dd$MZ,dd$L)]
blocks <-aggregate(dd, by=list(dd$MZ,dd$L), FUN=sum,na.rm=TRUE)#
blocks_mean<-aggregate(dd, by=list(dd$MZ,dd$L), FUN=mean,na.rm=TRUE)
dim(blocks)
dim(blocks_mean)
blocks_mean<-aggregate(dd, by=list(dd$MZ,dd$L), FUN=mean,na.rm=TRUE)#
names(blocks_mean)[1]<-"MANZANA"#
names(blocks_mean)[2]<-"LOC"
edit(blocks_mean)
drops <- c("MZ","LATITUDE","LONGITUDE")#
blocks[,!(names(blocks) %in% drops)]
<-read.csv("~/Dropbox/Incentives/Clusters/ASAEEDGPS_con_MZ.csv")
d<-read.csv("~/Dropbox/Incentives/Clusters/ASAEEDGPS_con_MZ.csv")
data<-d
head(data)#
data2 <- data[ , c("L", "V", "MZ")]#
data2$uniMZ <- as.factor(data2$L*100 + data2$MZ)#
data2$count <- 1
data2 <- data[ , c("L", "V", "MZ")]#
data2$uniMZ <- as.factor(data2$L*100 + data2$MZ)#
data2$count <- 1#
#
a <- as.data.frame(table(data2$uniMZ))#
names(a) <- c("uniMZ", "n")#
a$uniMZ1 <- as.character(a$uniMZ)#
a$cas <- substring(a$uniMZ, 2, 3)#
a$loc <- as.integer((as.integer(a$uniMZ1) - as.integer(a$cas))/100)#
a <- a[order(a$uniMZ),]#
a$ncum <- unlist(tapply(a$n, a$loc, cumsum))
head(a)
edit(a)
head(data)
plot(data$LATITUDE,data$LONGITUDE)
plot(data$LATITUDE,data$LONGITUDE,col=data$MZ)
plot(data$LATITUDE,data$LONGITUDE,col=data$CAPT+1,pch=18)
plot(data$LATITUDE,data$LONGITUDE,col=data$ENC+1,pch=18)
head(data)
data$count
data$Ltype
exp(-2.78)
4.8*.75
4+4+1+.84+.48+.36
4+4+1+.48+.36
.2*12
+9.84
+9.84+2.4
a
a<-c(2,12,69,96)
b<-c(149,333,315,286)
a/b
plot(a/b
)
r<- 1.5#
#
K<-50#
X0<-1#
nb<-100#
phi<-0.1#
#
logistic_map<-function(r,X){#
	X<-r*X*(1-X)#
	return(X)#
}#
discrete_logistic<-function(r,X,K){#
	X<-X+r*X*(1-X/K)#
	return(X)#
}#
poisson_logistic<-function(r,X,K){#
	X<-rpois(1,max(0,X+r*X*(1-X/K)))#
	return(X)#
}# give good outputs#
poisson_basic<-function(r,X,K){#
	X<-rpois(1,r*K/X)#
	return(X)#
}# very bad idea#
poisson_ricker<-function(r,X,K){#
	X<-rpois(1,X*exp(r*(1-X/K)))#
	return(X)#
}# works fine#
binom_mig<-function(X,phi){#
	Mig<-rbinom(1,X,phi)#
	return(Mig)#
}#
#
# beverton-holt model, see#
poisson_BH<-function(r,X,M){#
	X<-rpois(1,r*X/(1+X/M))#
	return(X)#
}#
#
Xs<-rep(0,nb+1)#
Ms<-rep(0,nb+1)#
# ## logistic map#
# Xs[1]<-X0#
# for(i in 1:nb){#
# 	Xs[i+1]<-logistic_map(r,Xs[i])#
# }#
# s<-K*(r/(r-1))#
# plot(Xs*s)#
#
## discrete logistic or poisson logistic#
Xs[1]<-X0#
M<-K/(r-1)#
for(i in 1:nb){#
	# Xs[i+1]<-discrete_logistic(r,Xs[i],K)#
	# Xs[i+1]<-poisson_logistic(r,Xs[i],K)#
	# Xs[i+1]<-poisson_basic(r,Xs[i],K)#
	Xs[i+1]<-poisson_ricker(r,Xs[i],K)#
	# Xs[i+1]<-poisson_BH(r,Xs[i],M)#
	Ms[i+1]<-binom_mig(Xs[i+1],phi)#
	Xs[i+1]<-Xs[i+1]-Ms[i+1]#
}#
plot(Xs,type="b")#
lines(Ms,type="b",col=4)
## discrete logistic or poisson logistic#
Xs[1]<-X0#
M<-K/(r-1)#
for(i in 1:nb){#
	# Xs[i+1]<-discrete_logistic(r,Xs[i],K)#
	# Xs[i+1]<-poisson_logistic(r,Xs[i],K)#
	# Xs[i+1]<-poisson_basic(r,Xs[i],K)#
	Xs[i+1]<-poisson_ricker(r,Xs[i],K)#
	# Xs[i+1]<-poisson_BH(r,Xs[i],M)#
	Ms[i+1]<-binom_mig(Xs[i+1],phi)#
	Xs[i+1]<-Xs[i+1]-Ms[i+1]#
}#
plot(Xs,type="b")#
lines(Ms,type="b",col=4)
Xs<-rep(0,nb+1)#
Ms<-rep(0,nb+1)#
 ## logistic map#
 Xs[1]<-X0#
 for(i in 1:nb){#
 	Xs[i+1]<-logistic_map(r,Xs[i])#
 }#
 s<-K*(r/(r-1))#
 plot(Xs*s)
dir()
heat.colors
heat.colors(.01)
heat.colors(.01*100)
heat.colors(.02*100)
?heat.colors
demo.pal <-#
  function(n, border = if (n < 32) "light gray" else NA,#
           main = paste("color palettes;  n=", n),#
           ch.col = c("rainbow(n, start=.7, end=.1)", "heat.colors(n)",#
                      "terrain.colors(n)", "topo.colors(n)",#
                      "cm.colors(n)"))#
{#
    nt <- length(ch.col)#
    i <- 1:n; j <- n / nt; d <- j/6; dy <- 2*d#
    plot(i, i+d, type = "n", yaxt = "n", ylab = "", main = main)#
    for (k in 1:nt) {#
        rect(i-.5, (k-1)*j+ dy, i+.4, k*j,#
             col = eval(parse(text = ch.col[k])), border = border)#
        text(2*j,  k * j + dy/4, ch.col[k])#
    }#
}#
n <- if(.Device == "postscript") 64 else 16#
     # Since for screen, larger n may give color allocation problem#
demo.pal(n)
n
library(rgl)
install.packages("rgl")
library("rgl")
plot3d(3,4,5)
plot3d(1:100,1:100,1:100)
text3d("test",5,5,5)
text3d(5,5,5)
text3d(texts=""test",5,5,5)
text3d(texts="test",5,5,5)
## other code#
## single.server <- function(beta, a = 0:(length(beta)-1), alpha, c, p, mu, javaClass) {#
##    treatedStats <- .jcall(javaClass,"[D","singleServer",.jarray(as.numeric(a)),.jarray(as.numeric(beta)), as.numeric(alpha), as.numeric(c), as.numeric(p), as.numeric(mu))#
##    return(treatedStats)#
## }#
#
## model parameters#
## beta - vector of size M containing redispersion rates for each age levels#
## a - vector of size M containing age levels#
## alpha - rate of infection in attack zone#
## c - participation rate#
## p - prevalence of infection#
## mu - service rate#
single.server.r <- function(beta, a=0:(length(beta)-1), alpha, c, p, mu) {#
	## initialization#
	alphaPrime <- alpha*(1-c)*p#
	M <- length(beta)#
	lambda <- beta + alphaPrime#
#
	## a at 1 must be 0#
	## note in R, the 1st index is the 0th index given by Brill's notation#
	a[1] <- 0#
#
	## initialize ending values of b, B, and M#
	b <- rep(0, length(beta))#
	b[M] <- 1#
#
	B <- rep(0, length(beta))#
	B[M] <- exp(-mu*a[M])/mu#
#
	G <- rep(0, length(beta))#
	G[M] <- exp(-(mu-lambda[M])*a[M])/(mu-lambda[M])#
#
	## recurrence loop#
	for(j in (M-1):1) {#
#
		b[j] <- -mu*(lambda[j+1]-lambda[j])/(lambda[j+1]-lambda[j]+mu)*exp((lambda[j+1]-lambda[j]+mu)*a[j+1])*B[j+1]#
				+exp((lambda[j+1]-lambda[j])*a[j+1])*b[j+1]#
#
		if(j+2<=M)#
			for(k in (j+2):M) {#
				b[j] <- b[j] + mu*((((lambda[k]-lambda[j+1])/(lambda[k]-lambda[j+1]+mu))-((lambda[k]-lambda[j])/(lambda[k]-lambda[j]+mu)))#
								*exp((lambda[k]-lambda[j]+mu)*a[j+1])*B[k])#
			}#
		B[j] <- b[j]*(exp(-mu*a[j])-exp(-mu*a[j+1]))/mu#
		for(k in (j+1):M) {#
			B[j] <- B[j] + mu*(((exp((lambda[k]-lambda[j])*a[j+1])-exp((lambda[k]-lambda[j])*a[j]))/(lambda[k]-lambda[j]+mu))*B[k]) #
		}#
		G[j] <- b[j]*(exp(-(mu-lambda[j])*a[j])-exp(-(mu-lambda[j])*a[j+1]))/(mu-lambda[j])#
		for(k in (j+1):M) {#
			G[j] <- G[j] + mu*((((lambda[k]-lambda[j])*(exp(lambda[k]*a[j+1])-exp(lambda[k]*a[j])))/((lambda[k]-lambda[j]+mu)*lambda[k]))*B[k])#
		}#
	}#
#
	## calculating the expected value#
	cMInverse <- 0#
#
	for(j in 1:M) {#
		cMInverse <- cMInverse + mu*B[j]/lambda[j] + G[j]#
	}#
	cM <- 1/cMInverse#
	eTreated <- 0#
#
	for(j in 1:M) {#
		eTreated <- eTreated + lambda[j]*G[j]*cM#
	}#
#
    variables <<- data.frame(a=a, b=b, B=B, G=G)#
    print(variables)#
	return(eTreated)#
}#
#
## initialize the java QueueModels framework#
## library("rJava")#
## .jinit(".")#
##queueModelsClass <- .jnew("QueueModels")#
#
## beta values from ages 0 to M (10 years)#
beta <- c(0.03151058, 0.2264334, 0.8135697, 1.8652304, 2.6427220, 2.9153079, 2.9816359, 2.9961008, 2.9991759, 2.9998260, 2.9999633, 2.9999922, 2.9999984,#
          2.9999997, 2.9999999, 3.0000000, 3.0000000, 3.0000000, 3.0000000, 3.0000000, 3.0000000)#
##beta <- c(rep(0, 5), rep(1, 6))#
#
## need to reassess these values but the code appears to be working!#
alpha <- 150#
c <- 0.70#
p <- 0.20#
mu <- 0.000050#
#
## expectedTreated1 <- single.server(beta=beta, alpha=alpha, c=c, p=p, mu=mu, javaClass=queueModelsClass)#
expectedTreated2 <- single.server.r(beta=beta, alpha=alpha, c=c, p=p, mu=mu)#
## print(expectedTreated1)#
print(expectedTreated2)#
#
##Plot output of a versus b, B, G#
# Install and call ggplot2#
# install.packages("ggplot2")#
library(ggplot2)#
library(grid)#
source("http://peterhaschke.com/Code/multiplot.R")#
#
## renames and set dataframe variable#
variables.plot <- variables #
#
## Plot output of a versus b#
P1 <- ggplot(variables.plot, aes(a, y = b, color = variable)) + geom_line(aes(y = b, col = "b"), #
            colour = "deepskyblue3") #
#
## Plot output of a versus B #
P2 <- ggplot(variables.plot, aes(a, y = B, color = variable)) + geom_line(aes(y = B, col = "B"),#
            colour = "forestgreen")#
#
## Plot output of a versus G#
P3 <- ggplot(variables.plot, aes(a, y = G, color = variable)) + geom_line(aes(y = G, col = "G"),#
            colour = "tomato3")#
#
## Plot output of graphes onto one page#
multiplot(P1, P2, P3, cols= 1)
for (i in 1:100*.000001)#
{#
    mu<-i#
    ## expectedTreated1 <- single.server(beta=beta, alpha=alpha, c=c, p=p, mu=mu, javaClass=queueModelsClass)#
    temp <- single.server.r(beta=beta, alpha=alpha, c=c, p=p, mu=mu)#
    ## print(expectedTreated1)#
    print(temp)#
}
## Brill's algorithm for a single server queue with a composite arrival stream#
## Based on Algorithm writeup MTR 09/29/2014#
#
## model parameters#
## beta - vector of size M containing redispersion rates for each age levels#
## a - vector of size M containing age levels#
## alpha - rate of infection in attack zone#
## c - participation rate#
## p - prevalence of infection#
## mu - service rate#
ActualRate <- function(beta, a=0:(length(beta)-1), alpha, c, p, mu) {#
	## initialization#
  ## alphaPrime = residual (external) arrival rate#
  ## lambda = vector of combined arrival rates (external + redispersion rate)#
	alphaPrime <- alpha*(1-c)*p#
	M <- length(beta)#
	lambda <- beta + alphaPrime#
#
	## a at 1 must be 0#
	## note in R, the 1st index is the 0th index given by Brill's notation#
	a[1] <- 0#
#
	## Step [1]: initialize ending values of b, B, and M#
	b <- rep(0, length(beta))#
	b[M] <- 1#
#
	B <- rep(0, length(beta))#
	B[M] <- exp(-mu*a[M])/mu#
#
	G <- rep(0, length(beta))#
	G[M] <- exp(-(mu-lambda[M])*a[M])/(mu-lambda[M])#
#
	## Step [2]: recurrence loop#
	for(j in (M-1):1) {#
#
		b[j] <- -mu*(lambda[j+1]-lambda[j])/(lambda[j+1]-lambda[j]+mu)*exp((lambda[j+1]-lambda[j]+mu)*a[j+1])*B[j+1]#
				+exp((lambda[j+1]-lambda[j])*a[j+1])*b[j+1]#
#
		if(j+2<=M)#
			for(k in (j+2):M) {#
				b[j] <- b[j] + mu*((((lambda[k]-lambda[j+1])/(lambda[k]-lambda[j+1]+mu))-((lambda[k]-lambda[j])/(lambda[k]-lambda[j]+mu)))#
								*exp((lambda[k]-lambda[j]+mu)*a[j+1])*B[k])#
			}#
		B[j] <- b[j]*(exp(-mu*a[j])-exp(-mu*a[j+1]))/mu#
		for(k in (j+1):M) {#
			B[j] <- B[j] + mu*(((exp((lambda[k]-lambda[j])*a[j+1])-exp((lambda[k]-lambda[j])*a[j]))/(lambda[k]-lambda[j]+mu))*B[k]) #
		}#
		G[j] <- b[j]*(exp(-(mu-lambda[j])*a[j])-exp(-(mu-lambda[j])*a[j+1]))/(mu-lambda[j])#
		for(k in (j+1):M) {#
			G[j] <- G[j] + mu*((((lambda[k]-lambda[j])*(exp(lambda[k]*a[j+1])-exp(lambda[k]*a[j])))/((lambda[k]-lambda[j]+mu)*lambda[k]))*B[k])#
		}#
	}#
#
	## Step [3]: calculating the normalization constant#
	cMInverse <- 0#
#
	for(j in 1:M) {#
		cMInverse <- cMInverse + mu*B[j]/lambda[j] + G[j]#
	}#
	cM <- 1/cMInverse#
	expTreated <- 0#
#
	for(j in 1:M) {#
		expTreated <- expTreated + lambda[j]*G[j]*cM#
	}#
#
    variables <<- data.frame(a=a, b=b, B=B, G=G)#
    print(variables)#
	return(expTreated)#
}#
#
## Provide input to program:#
#
## beta values from ages 0 to M; #
## note index in program runs 1 to M, where M=length(beta)#
## our first example: 10 years; M=11#
beta <- c(0.03151058, 0.2264334, 0.8135697, 1.8652304, 2.6427220, 2.9153079, 2.9816359, 2.9961008, 2.9991759, 2.9998260, 2.9999633)#
## beta values from ages 0 to M (10 years)#
## beta <- c(0.03151058, 0.2264334, 0.8135697, 1.8652304, 2.6427220, 2.9153079, 2.9816359, 2.9961008, 2.9991759, 2.9998260, 2.9999633, 2.9999922, 2.9999984,#
          ## 2.9999997, 2.9999999, 3.0000000, 3.0000000, 3.0000000, 3.0000000, 3.0000000, 3.0000000)#
##beta <- c(rep(0, 5), rep(1, 6))#
#
alpha <- 150#
##c <- 0.10#
p <- 0.20#
mu <- 20#
#
d<-(1:9)#
d<- d*0.1#
print(d)#
result<-c()#
for (j in 1:9)#
{#
  expectedTreated2 <- ActualRate(beta=beta, alpha=alpha, c=d[j], p=p, mu=mu)#
  result<-c(result, expectedTreated2)#
}#
print(result)#
#
## Plot of expected number of houses per year as function of participation rate, c#
variable.participation <- data.frame(c=d, result)#
plot(variable.participation)#
title("Participation Rate vs. Expected Number of Houses #
      per year")#
#
## Plot of expected number of houses per year as function of service rate, mu#
variable.service <- data.frame(mu, result)#
plot(variable.service)#
title("Service Rate vs. Expected Number of Houses #
      per year")#
##Plot output of a versus b, B, G when using constant rates of p, mu, c, alpha#
# Install and call ggplot2#
# install.packages("ggplot2")#
library(ggplot2)#
library(grid)#
source("http://peterhaschke.com/Code/multiplot.R")#
#
## renames and set dataframe variable#
variables.plot <- variables #
#
## Plot output of a versus b#
P1 <- ggplot(variables.plot, aes(a, y = b, color = variable)) + geom_line(aes(y = b, col = "b"), #
            colour = "deepskyblue3") #
#
## Plot output of a versus B #
P2 <- ggplot(variables.plot, aes(a, y = B, color = variable)) + geom_line(aes(y = B, col = "B"),#
            colour = "forestgreen")#
#
## Plot output of a versus G#
P3 <- ggplot(variables.plot, aes(a, y = G, color = variable)) + geom_line(aes(y = G, col = "G"),#
            colour = "tomato3")#
#
## Plot output of graphes onto one page#
multiplot(P1, P2, P3, cols= 1)
## Plot of expected number of houses per year as function of service rate, mu#
variable.service <- data.frame(mu, result)#
plot(variable.service)#
title("Service Rate vs. Expected Number of Houses #
      per year")
## Plot of expected number of houses per year as function of participation rate, c#
variable.participation <- data.frame(c=d, result)#
plot(variable.participation)#
title("Participation Rate vs. Expected Number of Houses #
      per year")
setwd("/Users/mzlevy/Jewell/Data")#
run.mcmc <- function(banditarm, totaliterations){#
#
#set seed#
set.seed(8527)#
#
#load libraries#
library("lubridate")#
library("PBSmapping")#
library("plyr")#
library("inline")#
library("Rcpp")#
#
##set up timer#
tic <- function(gcFirst = TRUE, type=c("elapsed", "user.self", "sys.self"))#
{#
  type <- match.arg(type)#
  assign(".type", type, envir=baseenv())#
  if(gcFirst) gc(FALSE)#
  tic <- proc.time()[type]         #
  assign(".tic", tic, envir=baseenv())#
}#
#
toc <- function()#
{#
  type <- get(".type", envir=baseenv())#
  toc <- proc.time()[type]#
  tic <- get(".tic", envir=baseenv())#
  toc - tic#
}
############################
###read data###############
##############################
#
tic()#
#
#read in data#
tiabaya.gps = read.csv("Tiabaya_GPS.csv")#
#
getUTM<-function(id, x,y){#
  coord <- data.frame(x,y)#
  colnames(coord) <- c("X","Y")#
  attributes(coord)$projection <- "LL"#
  utm.coord <- convUL(coord)#
  utm.coord$X<-utm.coord$X*1000#
  utm.coord$Y<-utm.coord$Y*1000#
  return(utm.coord)#
}#
tiabaya.test <- getUTM(x=tiabaya.gps$LONGITUDE,y=tiabaya.gps$LATITUDE)#
#
#link unicodes with coordinates#
tiabaya.gps <- cbind(tiabaya.gps$UNICODE,tiabaya.test)#
tiabaya.gps <- rename(tiabaya.gps,c("tiabaya.gps$UNICODE" = "UNICODE"))#
#read in data#
inspecciones = read.csv("inspecciones.csv")#
vig = read.csv("byHouse_fullEID.csv")#
priors = read.csv("Corentins_Predictions_Jun-24-2015_07-13-06.csv")#
rociado = read.csv("rociado.csv")#
#merge data#
i.v <- merge(inspecciones,vig, by="UNICODE",all=TRUE)#
i.v.gps <- merge(i.v,tiabaya.gps,by="UNICODE")#
data <- merge(i.v.gps, priors, by="UNICODE",all.x=TRUE)#
#
data$X <- NULL#
data$Y <- NULL#
names(data)[names(data)=="X.y"] <- "X"#
names(data)[names(data)=="Y.y"] <- "Y"#
#
#subset data to only include localities 4,5,6#
dataset <- data[which(data$L.y==4 | data$L.x==4 | data$L.y==5 | data$L.x==5 |data$L.y==6 | data$L.x==6),]
#drop all columns in rociado except unicode date of treatment and treatment ind#
rociado2 <- rociado[,c("UNICODE","DIA","MES","ANIO","T")]#
#rename rociado#
rociado2 <- data.frame(rociado2[1:1502,])#
colnames(rociado2) <-c("UNICODE", "DIA.T", "MES.T", "ANIO.T", "T")#
#
#Replace NA values with zeros for sum#
dataset$PD_TCAP_TOT <- ifelse(is.na(dataset$PD_TCAP_TOT),0,dataset$PD_TCAP_TOT)#
dataset$IN_TCAP_TOT <- ifelse(is.na(dataset$IN_TCAP_TOT),0,dataset$IN_TCAP_TOT)
########set up times########
#
#Import dates as separate columns for month, day and year in that respective order#
date <- function(m,d,y){#
  #Convert it into one string#
  right.date <- paste(m,d,y,sep = "/", collapse = NULL)#
  #Read it as a date in the right format for R#
  new.dates <- as.Date(right.date, "%m/%d/%Y")#
  return(new.dates)#
}#
#outputs dates in the correct format that R uses#
dataset$date <- date(dataset$MES,dataset$DIA,dataset$ANIO)#
#
#treatment dataset#
rociado2$date.T <- date(rociado2$MES.T,rociado2$DIA.T,rociado2$ANIO.T)
#############################################################
############# UPDATED CHANGES AND NEW FOR LOOP ##############
#############################################################
#if more than one observation for a house, pick most recent#
#
#identify unique unicodes#
unicode<-as.character(dataset$UNICODE)#
unicode.T <- as.character(rociado2$UNICODE)#
unique.unicodes <- unique(unicode)#
unique.unicodes.T <- unique(unicode.T)#
dates <- dataset$date#
dates.T <- rociado2$date.T#
#
#find repeated unicodes#
repeated.unicodes <- unicode[which(duplicated(unicode) == TRUE)]#
repeated.unicodes.T <- unicode.T[which(duplicated(unicode.T) == TRUE)]#
#setting an empty vector for the for loop#
unique.dates <- c(1:length(unique.unicodes)*NA)#
unique.dates.T <- c(1:length(unique.unicodes.T)*NA)#
#
#for houses with more than on observation, only take into account the one with latest date#
#
for (i in 1:length(unique.unicodes)){#
  u <- which(unicode==unique.unicodes[i])#
  fecha <- dataset$date[u]#
  if(is.na(fecha[1]) ==FALSE) {#
    maxf <- max(fecha, na.rm = TRUE)#
    v <- which(dataset$date == maxf)#
    unique.dates[i] <- intersect(u,v)#
  }#
  else {#
    unique.dates[i] <- max(u)#
  }#
}
for (i in 1:length(unique.unicodes.T)){#
  u <- which(unicode.T==unique.unicodes.T[i])#
  fecha <- rociado2$date.T[u]#
  if(is.na(fecha[1]) ==FALSE) {#
    maxf <- max(fecha, na.rm = TRUE)#
    v <- which(rociado2$date.T == maxf)#
    unique.dates.T[i] <- intersect(u,v)#
  }else{#
    unique.dates.T[i] <- max(u)#
  }#
}
#new dataframe with single unicodes #
unique.data <-dataset[unique.dates,]#
unique.data.T <- rociado2[unique.dates.T,]#
#
#merge inspected and treated datasets#
test <- merge(unique.data,unique.data.T,by="UNICODE",all.x=TRUE)#
dataset <- test
earliest <- sort(dataset$date)[1]#
latest <- sort(dataset$date)[length(dataset$date[which(!is.na(dataset$date))])]#
timetest <- (dataset$date - earliest)/90#
initialtime <- date(12, 31, 2004)#
today <- date(7, 22, 2015)#
timefrombeginning <- round((earliest - initialtime)/90)#
trueremovaltimetest <- (dataset$date.T - initialtime)/90#
tobs <- ceiling(timetest) + timefrombeginning#
maxt <- round((today - latest)/90)+max(tobs[which(!is.na(tobs))])#
maxt <- as.numeric(maxt)#
#
#set removal times#
trueremovaltimetest <- ifelse(is.na(trueremovaltimetest),Inf,trueremovaltimetest)
#identify which houses weren't inspected#
inspected <- ifelse(is.na(tobs),0,1)#
#
#replace NAs with max time#
tobs = ifelse(is.na(tobs), maxt,tobs)#
#
#sum inspecciones in districts 4,5,6#
sum.insp <- dataset$PD_TCAP_TOT + dataset$IN_TCAP_TOT#
#Replace NA values for prior probability with median value#
#find median value of those that are not NA#
median.pred.prob <- median(dataset$predicteddensity[which(!is.na(dataset$predicteddensity))])#
#
#replace NAs with this value#
predprobs <- ifelse(is.na(dataset$predicteddensity), median.pred.prob, dataset$predicteddensity)#
#
#get unicodes as strings#
unicode<-as.character(dataset$UNICODE)
#########################################################
#########MCMC algorithm####################################
########################################################
tic()   #begin timer#
##Jewell MCMC#
M <- totaliterations#
m <- 1 #first iteration#
#define number of houses#
N <- dim(dataset)[1]#
occult.sum.new<-rep(0,N)#
infectiontime<-rep(Inf,N)#
#
#calculate distances between houses#
distance<-matrix(NA,nrow=N,ncol=N)#
for (i in 1:N){#
  for (j in 1:N){#
    distance[i,j]=sqrt((dataset$X[i]-dataset$X[j])^2+(dataset$Y[i]-dataset$Y[j])^2)#
  }#
}
check3<- rep(Inf,N) #initialize data vector#
T_b <- 30 #threshold for bug infectiousness#
jumpprob <- .01 #probability of jump vs. hop#
bugs <- matrix(0,nrow=N,ncol=maxt) #initialize but matrix#
maxbugs <- max(sum.insp) #find most observed bugs in data#
initialinfective <- which(sum.insp==maxbugs) #set this house as initialinfective#
id=1:N #generate ids#
K=1000 #carrying capacity#
tuning <- 0.01 #tuning parameter for RJ
#option2: define threshold by radius of T_b#
#probability of infestation differs by hops (<T_b m) or jumps (>T_b m)#
threshold2 <- ifelse(distance<T_b, 1 , jumpprob)#
#decide which one you are using; this is what to change#
threshold <- threshold2#
#threshold <- threshold1#
#
check3<-ifelse(sum.insp>0,sum.insp,Inf) #replace with observed bug counts#
I=ifelse(check3!=Inf&check3!=Inf,2,Inf) #set initial values for infection times#
#
detectiontime=ifelse(check3>0&check3<Inf,tobs,Inf) #set detection time vector#
#
#initialize parameters #
beta=Rb=rep(0,M)#
beta[1]=.3#
betastar=.3#
betastar.I=matrix(0,nrow=N,ncol=N)#
betastar.sum=rep(0,N)#
S=H.mat=matrix(0,nrow=N,ncol=N)#
U=rep(0,N)#
accept.beta=accept.Iadd=accept.Idel=rep(0,M)#
#
#keep track of occult infestations#
occult=rep(0,N)#
#
#initialize infection times#
I[initialinfective]=1#
Istar=I#
#
#define indicators for infected houses#
N_N=which(check3!=Inf)#
N_I=which(I!=Inf)#
#take out initial infective#
N_N=N_N[which(N_N!=initialinfective)]#
N_I=N_I[which(N_I!=initialinfective)]#
infectedhouses=rep(0,N)#
infectedhouses[N_N]=1#
infectedhousesI=rep(0,N)#
infectedhousesI[N_I]=1#
#
#intialize bug mean vector#
lambda_t=rep(0,N)#
lambda_t[1]=1
#initialize Rb parameter#
Rb[1]=1.11#
#
#those treated before X date are counted as susceptible#
trueremovaltime <- ceiling(ifelse(trueremovaltimetest<=10&I==Inf,Inf,trueremovaltimetest))#
trueremovaltime <- ifelse(trueremovaltime<tobs&check3<Inf,Inf,trueremovaltime)
`%notin%` <- function(x,y) !(x %in% y) #
#
sampleWithoutSurprises <- function(x) {#
  if (length(x) <= 1) {#
    return(x)#
  } else {#
    return(sample(x,1))#
  }#
}#
#BH function to update bug counts given matrix#
beverton.holt<-function(id,K,R,bugs,maxt,trueinfectiontime){#
  for(t in trueinfectiontime:(maxt-1)){#
    bugs[id,(t+1)]=ceiling(R*bugs[id,t]/(1+bugs[id,t]/(K/(R-1))))#
  }#
  return(bugs[id,])#
}#
#
#BH function to update infection times#
beverton.holt.I<-function(update,K,R,check3,tobs){#
  tobs1=tobs#
  time=ifelse(update %in% N_N, -log((K-check3[update])/(check3[update]*K-check3[update]))/log(R[m-1]),-log((K-bugs[update,tobs1])/(bugs[update,tobs1]*K-bugs[update,tobs1]))/log(R[m-1]))#
  I[update]=tobs1-time#
  return(I[update])#
}#
#BH function to udpate bug counts given vector#
beverton.holt.update<-function(K,R,bugs,trueremovaltime,trueinfectiontime){#
  for(t in trueinfectiontime:(min(maxt-1,trueremovaltime-1))){#
    bugs[(t+1)]=ceiling(R*bugs[t]/(1+bugs[t]/(K/(R-1))))#
  }#
  return(bugs)#
}#
#hazard function#
ht <- function(t, r, I, i, j, beta, K, threshold) {#
  n <- 1#
  deriv <- K*n^2*log(r)/((K-n)*exp(-log(r)*(t-I[i]))+n)^2#
  ifelse(deriv>0, 1-(1-beta*threshold[i,j])^(deriv), 0)#
}#
#
#cumulative hazard function#
H<-function(i,j,t,Rb,I,beta){#
  r=log(Rb)#
  Ht=t*(1-(1-beta*threshold[i,j])^(r/K))-#
    ((K-1)*r^2*t^2*log(1-beta*threshold[i,j])*(1-beta*threshold[i,j])^(r/K))/(K^2)-#
    t^3*((K-1)*r^3*log(1-beta*threshold[i,j])*(1-beta*threshold[i,j])^(r/K)*(2*(K-1)*r*#
                                                                               log(1-beta*threshold[i,j])+K*(2*K-3)))/(3*K^4)#
  return(Ht)}#
#
#second piece of likelihood#
secondpiece.update<-function(i,trueremovaltime,detectiontime,I,beta,r){#
  S1=rep(0,N)#
  for (j in 1:N){#
    t=min(maxt,I[i],trueremovaltime[i])-min(I[j],I[i])#
    if(t>0) S1[j]<-H(i, j, t, r, I, beta, K, threshold)#
  }#
  S1<-ifelse(S1=="NaN",0,S1)  #
  sumofS=sum(S1)#
  return(sumofS)#
}#
#
firstpiece.update<-function(update,I,beta,initialinfective,r){#
  beta.I=H.mat=H.mat1=matrix(0,nrow=N,ncol=N)#
  beta.sum=rep(0,N)#
  j=update#
  t = tobs[update]#
  for (i in 1:N) if(i %in% N_I | i==initialinfective) {#
    if(I[i]<I[j]&I[j]<trueremovaltime[i]) H.mat[i,j]=ht(t, r, I, i, j, beta, K, threshold)#
  }#
  beta.sum=sum(H.mat[,j])#
  tempthres1=N#
  beta.sum<-ifelse(is.na(beta.sum),0,beta.sum)#
  return(beta.sum)#
}#
#poisson piece of likelihood for matrix#
f_D<-function(i,bugs,I,check3,Rb){#
  den=0#
  lambda_t=beverton.holt.update(K,Rb,lambda_t,trueremovaltime[i],1)#
  if(check3[i]<Inf){#
    adjusted.bugs=bugs[i,which(bugs[i,]!=0)]#
    den=den+dpois(adjusted.bugs,lambda_t[1:length(adjusted.bugs)],log=TRUE)#
  }#
  return(den)#
}#
#
#poisson piece of likelihood for vector#
f_D.update<-function(i,bugs,I,check3,Rb){#
  den=0#
  lambda_t=beverton.holt.update(K,Rb,lambda_t,trueremovaltime[i],1)#
  if(check3[i]<Inf){#
    adjusted.bugs=bugsstar[which(bugsstar!=0)]#
    den=den+dpois(adjusted.bugs,lambda_t[1:length(adjusted.bugs)],log=TRUE)#
  }#
  return(den)#
}
#' First piece of likelihood#
#'#
#' @param I Numeric vector of times.#
#' @param beta Float hazard rate for infection.#
#' @param initialinfective Cardinal of initial infected house.#
#' @param r Growth rate, a float.#
#' @param K Distance factor?, a float.#
#' @param N Number of houses.#
#' @param N_I Those houses that were surveiled? A list of indices.#
#' @param threshold NxN matrix of float cutoff distances.#
#' @return Array of likelihoods, as numeric vector.#
firstpiece <- function(I, beta, initialinfective, r, K, N, N_I, threshold) {#
  H.mat <- matrix(0, nrow=N, ncol=N)#
  beta.sum <- rep(0, N)#
  for (j in 1:N) {#
    for (i in 1:N) {#
      if (i %in% N_I | i==initialinfective) {#
        if (I[i]<I[j] & I[j]<Inf) {#
          n <- 1#
          deriv <- K*n^2*log(r)/((K-n)*exp(-log(r)*(I[j]-I[i]))+n)^2#
          H.mat[i,j] <- ifelse(deriv>0, 1-(1-beta*threshold[i,j])^(deriv), 0)#
          # print(paste("i", i, "j", j, "I[i]", I[i], "I[j]", I[j],#
          #   "deriv", deriv, "hmat", H.mat[i,j]))#
        }#
      }#
    }#
    beta.sum[j] <- sum(H.mat[,j])#
  }#
  ifelse(is.na(beta.sum), 0, beta.sum)#
}#
#
first.include <- '#
#include <set>#
#include <cmath>#
'#
#
firstpiece.wrap <- cxxfunction(signature(IS="numeric", betaS="float",#
                                         initialinfectiveS="int", rS="float", KS="float", NS="int", N_IS="numeric",#
                                         thresholdS="numeric"), plugin="Rcpp", incl=first.include, body='#
                               Rcpp::NumericVector I(IS);#
                               double beta=Rcpp::as<double>(betaS);#
                               int initialinfective=Rcpp::as<int>(initialinfectiveS);#
                               double r=Rcpp::as<double>(rS);#
                               double K=Rcpp::as<double>(KS);#
                               int N=Rcpp::as<int>(NS);#
                               Rcpp::NumericVector N_I(N_IS);#
                               Rcpp::NumericVector threshold(thresholdS);#
                               std::set<int> infecteds(N_I.begin(), N_I.end());#
                               typedef std::set<int>::const_iterator infiter;#
                               infecteds.insert(initialinfective);#
                               Rcpp::NumericVector H(N, 0.0);#
                               const int n=1;#
                               for (int j=0; j<N; ++j) {#
                               double total=0;#
                               for (infiter it=infecteds.begin(); it!=infecteds.end(); ++it) {#
                               int i=*it - 1; // -1 to convert to 0-based indexing.#
                               if (I[i]<I[j] && std::isfinite(I[j])) {#
                               double deriv=K*std::pow(n, 2)*std::log(r)/#
                               std::pow(#
                               (K-n)*std::exp(#
                               -std::log(r)*(I[j]-I[i])#
                               )+n,#
                               2#
                               );#
                               if (deriv>0) {#
                               double add=1-std::pow(1-beta*threshold[i*N+j], deriv);#
                               //std::cout << "i "<<i<<" j " << j<<" I i "<<I[i]<<" I[j] "<< I[j]#
                               //  <<" deriv " << deriv << " hmat " << add <<std::endl;#
                               total+=add;#
                               }#
                               }#
                               }#
                               H[j]=total;#
                               }#
                               return H;#
                               ')#
H <- function(i, j, t, Rb, I, beta, K, threshold) {#
  r <- log(Rb)#
  obt <- (1-beta*threshold[i,j])^(r/K)#
  t*(1-obt)-((K-1)*r^2*t^2*log(1-beta*threshold[i,j])*obt)/(K^2)-#
    t^3*((K-1)*r^3*log(1-beta*threshold[i,j])*obt*(2*(K-1)*r*#
                                                     log(1-beta*threshold[i,j])+K*(2*K-3)))/(3*K^4)#
}#
#
#' Second piece of likelihood#
#'#
#' @param I Numeric vector of times.#
#' @param beta Float hazard rate for infection.#
#' @param r Growth rate, a float.#
#' @param K Distance factor?, a float.#
#' @param N Number of houses.#
#' @param maxt A maximum time, a float.#
#' @param threshold NxN matrix of float cutoff distances.#
#' @return Single sum, a float.#
secondpiece <- function(I, beta, r, K, N, maxt, threshold) {#
  S1 <- matrix(0, nrow=N, ncol=N)#
  for (i in 1:N) {#
    if (I[i]!=Inf) {#
      for (j in 1:N) {#
        t <- min(maxt, I[j]) - min(I[i], I[j])#
        if (t>0) {#
          S1[i,j] <- H(i, j, t, r, I, beta, K, threshold)#
        }#
      }#
    }#
  }#
  S1<-ifelse(S1=="NaN", 0, S1)  #
  sum(S1)#
}#
secondpiece.wrap <- cxxfunction(signature(IS="numeric", trueremovaltimeS="numeric", betaS="float",#
                                          rS="float", KS="float", NS="int", maxtS="float",#
                                          thresholdS="numeric"), plugin="Rcpp", incl=first.include, body='#
                                Rcpp::NumericVector I(IS);#
                                Rcpp::NumericVector trueremovaltime(trueremovaltimeS);#
                                double beta=Rcpp::as<double>(betaS);#
                                double logr=std::log(Rcpp::as<double>(rS));#
                                double K=Rcpp::as<double>(KS);#
                                int N=Rcpp::as<int>(NS);#
                                double maxt=Rcpp::as<double>(maxtS);#
                                Rcpp::NumericVector threshold(thresholdS);#
                                double total=0;#
                                for (int i=0; i<N; ++i) {#
                                if (std::isfinite(I[i])) {#
                                for (int j=0; j<N; ++j) {#
                                double t=std::min(std::min(maxt, I[j]),trueremovaltime[i]) - std::min(I[i], I[j]);#
                                if (t>0) {#
                                double obt=std::pow(1-beta*threshold[i*N+j], logr/K);#
                                double add=t*(1-obt)-((K-1)*logr*logr*t*t*std::log(1-beta*threshold[i*N+j])*obt)/(K*K)-#
                                std::pow(t, 3)*((K-1)*std::pow(logr, 3)*std::log(1-beta*threshold[i*N+j])*obt*(2*(K-1)*logr*#
                                std::log(1-beta*threshold[i*N+j])+K*(2*K-3)))/(3*std::pow(K, 4));#
                                if (std::isfinite(add)) {#
                                total+=add;#
                                }#
                                }#
                                }#
                                }#
                                }#
                                return Rcpp::wrap(total);#
                                ')#
###############################
#########for loop begins########
###############################
bugsize=NULL#
infectiontime=I#
id = 1:N#
#
#find initial infectives notification and recovery times#
infectiontime[initialinfective]<-1#
bugs[initialinfective,1]<-1#
bugs[initialinfective,]=rpois(maxt,beverton.holt(initialinfective,K,Rb[1],bugs,min(maxt,trueremovaltime[initialinfective]),infectiontime[initialinfective]))#
#
#initialize bug counts#
for (i in which(I!=Inf)){#
  bugs[i,I[i]]=1#
  bugstemp=beverton.holt(i,K[1],Rb[1],bugs,min(maxt,trueremovaltime[i]),I[i])#
  bugs[i,(I[i]:min(trueremovaltime[i],maxt))]=rpois((min(maxt,trueremovaltime[i])-I[i]+1),bugstemp[I[i]:min(maxt,trueremovaltime[i])])#
  bugs[i,tobs[i]]=ifelse(check3[i]<Inf,check3[i],bugs[i,tobs[i]])#
}
for (m in 2:M){#
  ################
  ##update beta###
  ################
  betastar=abs(rnorm(1,beta[m-1],.01))#
  if(betastar > 1) betastar <- 1-(betastar-1)#
  logfirstpiecestar<-log(firstpiece.wrap(I, betastar, initialinfective, Rb[m-1], K, N, N_I, threshold) )#
  logfirstpiecestar=ifelse(logfirstpiecestar=="-Inf",0,logfirstpiecestar)#
  logfirstpiece<-log(firstpiece.wrap(I, beta[m-1], initialinfective, Rb[m-1], K, N, N_I, threshold))#
  logfirstpiece=ifelse(logfirstpiece=="-Inf",0,logfirstpiece)#
  dbetastar=sum(logfirstpiecestar)-secondpiece.wrap(I, trueremovaltime, betastar, Rb[m-1], K, N, maxt, threshold)+dunif(betastar,min=.001,max=.99,log=TRUE)#
  dbeta=sum(logfirstpiece)-secondpiece.wrap(I, trueremovaltime, beta[m-1], Rb[m-1], K, N, maxt, threshold)+dunif(beta[m-1],min=.001,max=.99,log=TRUE)#
  mstep.beta=min(1,exp(sum(dbetastar)-sum(dbeta)))#
  if(mstep.beta=="NaN") mstep.beta=1#
  R=runif(1)#
  if(R<mstep.beta){#
    beta[m]=betastar#
    #accept.beta[m]=1#
  }else{#
    beta[m]=beta[m-1]#
    #accept.beta[m]=0#
  }#
  ########################################################
  #############update times###############################
  ########################################################
  #############
  ##update I###
  #############
  ##pick a house to update the time out infected houses#
  update=sample(N_I,1)#
  if(bugs[update,min(maxt,trueremovaltime[update])]==0) bugs[update,min(maxt,trueremovaltime[update])]=1#
  Istar[update]=ifelse(check3[update]>0,round(rnorm(1,beverton.holt.I(update,K,Rb,check3,tobs[update]),1)),floor(rnorm(1,beverton.holt.I(update,K,Rb,bugs[,min(maxt,trueremovaltime[update])], min(maxt,trueremovaltime[update])),1)))#
  if(Istar[update]=="NaN") {bugs[update,min(maxt,trueremovaltime[update])]=1000#
                            Istar[update]=ifelse(check3[update]>0,round(beverton.holt.I(update,K,Rb,check3,tobs[update])),floor(beverton.holt.I(update,K,Rb,bugs[,min(maxt,trueremovaltime[update])], min(maxt,trueremovaltime[update]))))#
  }#
  if(Istar[update]>=maxt) Istar[update]=maxt-1#
  Istar[update]=ifelse(Istar[update]<1,2,Istar[update])#
  bugsstar=rep(0,maxt)#
  bugsstar[Istar[update]]=1#
  bugsstar=beverton.holt.update(K,Rb[m-1],bugsstar,trueremovaltime[update],Istar[update])#
  bugsstar[tobs[update]]=check3[update]#
  logfirstpieceI<-log(firstpiece.wrap(I, beta[m], initialinfective, Rb[m-1], K, N, N_I, threshold))#
  logfirstpieceI=ifelse(logfirstpieceI=="-Inf",0,logfirstpieceI)#
  loglike.I=sum(logfirstpieceI)-secondpiece.wrap(I, trueremovaltime, beta[m], Rb[m-1], K, N, maxt, threshold)#
  logfirstpieceIstar<-log(firstpiece.wrap(Istar, beta[m], initialinfective, Rb[m-1], K, N, N_I, threshold) )#
  logfirstpieceIstar=ifelse(logfirstpieceIstar=="-Inf",0,logfirstpieceIstar)#
  loglike.Istar=sum(logfirstpieceIstar)-secondpiece.wrap(Istar, trueremovaltime, beta[m], Rb[m-1], K, N, maxt, threshold)#
  Q=sum(f_D.update(update,bugsstar,Istar,check3,Rb[m-1]))-sum(f_D(update,bugs,I,check3,Rb[m-1]))#
  #Metroplis step; decide whether to accept new time##
  mstep.I=min(1,exp(loglike.Istar-loglike.I+Q))#
  if(mstep.I=="NaN") mstep.I=1#
  R=runif(1)#
  if(R<mstep.I){#
    I<-Istar#
    bugs[update,]=bugsstar#
    loglike.I<-loglike.Istar#
  }else{#
    Istar<-I#
  }#
  #################################
  ######update Rb###################
  #####################################
  Rbstar=rnorm(1,Rb[m-1],.1)#
  if(Rbstar <=1) Rbstar <- 1+(1-Rbstar)#
  Q=Qstar=rep(NA,length(I!=Inf))#
  for (i in which(I!=Inf)){#
    Qstartemp <- f_D(i,bugs,I,check3,Rbstar)#
    Qstartemp <- Qstartemp[which(Qstartemp!=-Inf)]#
    Qstar[i]=sum(Qstartemp)#
    Qtemp <- f_D(i,bugs,I,check3,Rb[m-1])#
    Qtemp <- Qtemp[which(Qtemp!=-Inf)]#
    Q[i]=sum(Qtemp)#
  }#
  thirdpieceloglike=sum(Qstar[which(Qstar!="NA")])-sum(Q[which(Q!="NA")])+dunif(Rbstar,min=1,max=2,log=TRUE)-dunif(Rb[m-1],min=1,max=2,log=TRUE)#
  logfirstpieceIstar<-log(firstpiece.wrap(I, beta[m], initialinfective, Rbstar, K, N, N_I, threshold) )#
  logfirstpieceIstar=ifelse(logfirstpieceIstar=="-Inf",0,logfirstpieceIstar)#
  loglike.Istar=sum(logfirstpieceIstar)-secondpiece.wrap(I, trueremovaltime, beta[m], Rbstar, K, N, maxt, threshold)#
  Rbloglike=loglike.Istar+thirdpieceloglike-loglike.I#
  #Metropolis step#
  mstep.Rb=min(0,Rbloglike)#
  #if(mstep.Rb=="NaN") mstep.Rb=0#
  R=log(runif(1))#
  if(R<mstep.Rb){#
    Rb[m]=Rbstar#
    loglike.I<-loglike.Istar#
    Q<-Qstar#
  }else{#
    Rb[m]=Rb[m-1]}#
  #########################################################
  #####decide whether to update I, add I, or delete I######
  #########################################################
  add.del<-sample(c("add","del"),1)#
  if(add.del=="add"){ #
    ############
    ###add I####
    ###########
    addinf<-which((I==Inf&tobs<maxt-2&inspected==1)|(I==Inf&inspected==0))#
    if(length(addinf)>1){#
      update=sample(addinf,1)#
      Istar[update]=ifelse(inspected[update]==1,floor(runif(1,min=tobs[update],max=maxt-1)),floor(runif(1,min=2,max=maxt-2)))#
      trueremovaltime[update]=maxt+1#
      detectiontime[update]=maxt#
      tobs[update]=maxt#
      bugsstar=rep(0,maxt)#
      bugsstar[Istar[update]]=1#
      bugsstar=beverton.holt.update(K,Rb[m],bugsstar,trueremovaltime[update],Istar[update])#
      bugstest=bugs#
      bugstest[update,]=bugsstar[1:maxt]#
      check3[update]<-ifelse(inspected[update]==1,0,bugsstar[tobs])#
  logfirstpieceI<-log(firstpiece.wrap(I, beta[m], initialinfective, Rb[m], K, N, N_I, threshold))#
  logfirstpieceI=ifelse(logfirstpieceI=="-Inf",0,logfirstpieceI)#
  loglike.I=sum(logfirstpieceI)-secondpiece.wrap(I, trueremovaltime, beta[m], Rb[m], K, N, maxt, threshold)#
  logfirstpieceIstar<-log(firstpiece.wrap(Istar, beta[m], initialinfective, Rb[m], K, N, N_I, threshold) )#
  logfirstpieceIstar=ifelse(logfirstpieceIstar=="-Inf",0,logfirstpieceIstar)#
  loglike.Istar=sum(logfirstpieceIstar)-secondpiece.wrap(Istar, trueremovaltime, beta[m], Rb[m], K, N, maxt, threshold)#
      alpha.p <- predprobs[update]#
      beta.p <- 1-alpha.p#
      probifadded <- (sum(occult[update])+1)/m#
      probifnotadded <- sum(occult[update]+.000000000000001)/m#
      extra.piece=(length(addinf))/(maxt*(length(N_I)-length(N_N)+1))*dbeta(probifadded, alpha.p, beta.p) #/dbeta(probifnotadded, alpha.p, beta.p)#
      #metropolis hastings step for adding an infection#
      mstep.I=min(1,exp(loglike.Istar-loglike.I)*extra.piece)#
      if(mstep.I=="NaN") mstep.I=1#
      R=runif(1)#
      if(R<mstep.I){#
        I<-Istar#
        N_I<-c(N_I,update)#
        infectedhousesI[N_I]=1#
        #accept.Iadd[m]=1#
        bugs[update,]=bugsstar#
        loglike.I<-loglike.Istar#
        Q<-Qstar#
      }else{#
        Istar<-I#
        #accept.Iadd[m]=2#
        trueremovaltime[update]=tobs[update]=maxt#
        detectiontime[update] <- Inf#
        check3[update]<-Inf}#
    }#
  }else{#
    ################
    ####delete I####
    ################
    if(length(N_I)>length(N_N)){ #
      #pick which house to delete#
      update=sampleWithoutSurprises(N_I[!(N_I %in% N_N)])#
      Istar[update]=Inf#
      check3[update]=Inf#
      tobs[update]=maxt#
      trueremovaltime[update]=detectiontime[update]=Inf#
      bugsstest<-bugs#
      bugstest[update,]=0#
  logfirstpieceI<-log(firstpiece.wrap(I, beta[m], initialinfective, Rb[m], K, N, N_I, threshold))#
  logfirstpieceI=ifelse(logfirstpieceI=="-Inf",0,logfirstpieceI)#
  loglike.I=sum(logfirstpieceI)-secondpiece.wrap(I, trueremovaltime, beta[m], Rb[m], K, N, maxt, threshold)#
  logfirstpieceIstar<-log(firstpiece.wrap(Istar, beta[m], initialinfective, Rb[m], K, N, N_I, threshold) )#
  logfirstpieceIstar=ifelse(logfirstpieceIstar=="-Inf",0,logfirstpieceIstar)#
  loglike.Istar=sum(logfirstpieceIstar)-secondpiece.wrap(Istar, trueremovaltime, beta[m], Rb[m], K, N, maxt, threshold)#
  alpha.p <- predprobs[update]#
      beta.p <- 1-alpha.p#
      probifdeleted <- (sum(occult[update])-1)/m#
      probifnotdeleted <- sum(occult[update])/m#
      extra.piece=maxt*(length(N_I)-length(N_N))/(length(addinf))*dbeta(probifdeleted, alpha.p, beta.p) #/dbeta(probifnotdeleted, alpha.p, beta.p)#
      #decide whether to accept new I#
      mstep.I=min(1,exp(loglike.Istar-loglike.I)*extra.piece)#
      if(mstep.I=="NaN") mstep.I=1#
      R=runif(1)#
      if(R<mstep.I){#
        I<-Istar#
        N_I<-N_I[which(N_I!=update)]#
        #accept.Idel[m]=1#
        loglike.I<-loglike.Istar#
        infectedhousesI[update]=0#
        Q<-Qstar#
        bugs<-bugstest#
      }else{#
        Istar<-I#
        trueremovaltime[update]=Inf#
        tobs[update]=maxt#
        detectiontime[update]=Inf#
        #accept.Idel[m]=2#
        check3[update]=bugs[update,tobs[update]]}#
    }#
  }#
  occult[N_I[!(N_I %in% N_N)]]=occult[N_I[!(N_I %in% N_N)]]+1#
  #occult.sum <- apply(occult,1,sum)#
  occult.prob<- occult/m#
  occult.prob.ids <- cbind(id, occult.prob, dataset$X, dataset$Y)#
  occult.prob.ids.ordered <- cbind(occult.prob.ids,unicode)#
  occult.prob.ids.ordered <- occult.prob.ids.ordered[order(occult.prob, decreasing = TRUE),]#
  }#
toc()#
return(occult.prob.ids.ordered)#
#
}
Results1 <- run.mcmc(1,5)
setwd("/Users/mzlevy/Jewell/Data")
setwd("/Users/mzlevy/Jewell/Data")
#set seed#
set.seed(8527)#
#
#load libraries#
library("lubridate")#
library("PBSmapping")#
library("plyr")#
library("inline")#
library("Rcpp")#
#
##set up timer#
tic <- function(gcFirst = TRUE, type=c("elapsed", "user.self", "sys.self"))#
{#
  type <- match.arg(type)#
  assign(".type", type, envir=baseenv())#
  if(gcFirst) gc(FALSE)#
  tic <- proc.time()[type]#
  assign(".tic", tic, envir=baseenv())#
}#
#
toc <- function()#
{#
  type <- get(".type", envir=baseenv())#
  toc <- proc.time()[type]#
  tic <- get(".tic", envir=baseenv())#
  toc - tic#
}#
#
############################
###read data###############
##############################
#
tic()#
#
#read in data#
tiabaya.gps = read.csv("Tiabaya_GPS.csv")#
#
getUTM<-function(id, x,y){#
  coord <- data.frame(x,y)#
  colnames(coord) <- c("X","Y")#
  attributes(coord)$projection <- "LL"#
  utm.coord <- convUL(coord)#
  utm.coord$X<-utm.coord$X*1000#
  utm.coord$Y<-utm.coord$Y*1000#
  return(utm.coord)#
}#
tiabaya.test <- getUTM(x=tiabaya.gps$LONGITUDE,y=tiabaya.gps$LATITUDE)#
#
#link unicodes with coordinates#
tiabaya.gps <- cbind(tiabaya.gps$UNICODE,tiabaya.test)#
tiabaya.gps <- rename(tiabaya.gps,c("tiabaya.gps$UNICODE" = "UNICODE"))#
#read in data#
inspecciones = read.csv("inspecciones.csv")#
vig = read.csv("byHouse_fullEID.csv")#
priors = read.csv("Corentins_Predictions_Jun-24-2015_07-13-06.csv")#
rociado = read.csv("rociado.csv")#
#merge data#
i.v <- merge(inspecciones,vig, by="UNICODE",all=TRUE)#
i.v.gps <- merge(i.v,tiabaya.gps,by="UNICODE")#
data <- merge(i.v.gps, priors, by="UNICODE",all.x=TRUE)#
#
data$X <- NULL#
data$Y <- NULL#
names(data)[names(data)=="X.y"] <- "X"#
names(data)[names(data)=="Y.y"] <- "Y"#
#
#subset data to only include localities 4,5,6#
dataset <- data[which(data$L.y==4 | data$L.x==4 | data$L.y==5 | data$L.x==5 |data$L.y==6 | data$L.x==6),]#
#drop all columns in rociado except unicode date of treatment and treatment ind#
rociado2 <- rociado[,c("UNICODE","DIA","MES","ANIO","T")]#
#rename rociado#
rociado2 <- data.frame(rociado2[1:1502,])#
colnames(rociado2) <-c("UNICODE", "DIA.T", "MES.T", "ANIO.T", "T")#
#
#Replace NA values with zeros for sum#
dataset$PD_TCAP_TOT <- ifelse(is.na(dataset$PD_TCAP_TOT),0,dataset$PD_TCAP_TOT)#
dataset$IN_TCAP_TOT <- ifelse(is.na(dataset$IN_TCAP_TOT),0,dataset$IN_TCAP_TOT)#
#
###################################################
#######define parameters
#Import dates as separate columns for month, day and year in that respective order#
date <- function(m,d,y){#
  #Convert it into one string#
  right.date <- paste(m,d,y,sep = "/", collapse = NULL)#
  #Read it as a date in the right format for R#
#
  new.dates <- as.Date(right.date, "%m/%d/%Y")#
#
  return(new.dates)#
}#
#outputs dates in the correct format that R uses#
dataset$date <- date(dataset$MES,dataset$DIA,dataset$ANIO)#
#
#treatment dataset#
rociado2$date.T <- date(rociado2$MES.T,rociado2$DIA.T,rociado2$ANIO.T)#
#############################################################
############# UPDATED CHANGES AND NEW FOR LOOP ##############
#############################################################
#if more than one observation for a house, pick most recent#
#
#identify unique unicodes#
unicode<-as.character(dataset$UNICODE)#
unicode.T <- as.character(rociado2$UNICODE)#
unique.unicodes <- unique(unicode)#
unique.unicodes.T <- unique(unicode.T)#
dates <- dataset$date#
dates.T <- rociado2$date.T#
#
#find repeated unicodes#
repeated.unicodes <- unicode[which(duplicated(unicode) == TRUE)]#
repeated.unicodes.T <- unicode.T[which(duplicated(unicode.T) == TRUE)]#
#setting an empty vector for the for loop#
unique.dates <- c(1:length(unique.unicodes)*NA)#
unique.dates.T <- c(1:length(unique.unicodes.T)*NA)#
#
#for houses with more than on observation, only take into account the one with latest date#
#
for (i in 1:length(unique.unicodes)){#
#
  u <- which(unicode==unique.unicodes[i])#
  fecha <- dataset$date[u]#
#
  if(is.na(fecha[1]) ==FALSE) {#
    maxf <- max(fecha, na.rm = TRUE)#
    v <- which(dataset$date == maxf)#
    unique.dates[i] <- intersect(u,v)#
  }#
  else {#
    unique.dates[i] <- max(u)#
  }#
}#
for (i in 1:length(unique.unicodes.T)){#
#
  u <- which(unicode.T==unique.unicodes.T[i])#
  fecha <- rociado2$date.T[u]#
#
  if(is.na(fecha[1]) ==FALSE) {#
    maxf <- max(fecha, na.rm = TRUE)#
    v <- which(rociado2$date.T == maxf)#
    unique.dates.T[i] <- intersect(u,v)#
  }else{#
    unique.dates.T[i] <- max(u)#
  }#
}#
#new dataframe with single unicodes#
unique.data <-dataset[unique.dates,]#
unique.data.T <- rociado2[unique.dates.T,]#
#
#merge inspected and treated datasets#
test <- merge(unique.data,unique.data.T,by="UNICODE",all.x=TRUE)#
dataset <- test#
earliest <- sort(dataset$date)[1]#
latest <- sort(dataset$date)[length(dataset$date[which(!is.na(dataset$date))])]#
timetest <- (dataset$date - earliest)/90#
initialtime <- date(12, 31, 2004)#
today <- date(7, 22, 2015)#
timefrombeginning <- round((earliest - initialtime)/90)#
trueremovaltimetest <- (dataset$date.T - initialtime)/90#
tobs <- ceiling(timetest) + timefrombeginning#
maxt <- round((today - latest)/90)+max(tobs[which(!is.na(tobs))])#
maxt <- as.numeric(maxt)
T.b
Tb
ls()
#set removal times#
trueremovaltimetest <- ifelse(is.na(trueremovaltimetest),Inf,trueremovaltimetest)#
#
#identify which houses weren't inspected#
inspected <- ifelse(is.na(tobs),0,1)#
#
#Set all homes as uninspected#
inspected <- ifelse(inspected, 1, 1)#
#
#replace NAs with max time#
tobs = ifelse(is.na(tobs), maxt,tobs)#
#
#sum inspecciones in districts 4,5,6#
sum.insp <- dataset$PD_TCAP_TOT + dataset$IN_TCAP_TOT#
#
#Replace NA values for prior probability with median value#
#find median value of those that are not NA#
median.pred.prob <- median(dataset$predicteddensity[which(!is.na(dataset$predicteddensity))])#
#
#replace NAs with this value#
predprobs <- ifelse(is.na(dataset$predicteddensity), median.pred.prob, dataset$predicteddensity)#
#
#get unicodes as strings#
unicode<-as.character(dataset$UNICODE)#
#########################################################
#########MCMC algorithm####################################
########################################################
tic()   #begin timer#
##Jewell MCMC#
M <- totaliterations#
m <- 1 #first iteration#
#define number of houses#
N <- dim(dataset)[1]#
occult.sum.new<-rep(0,N)#
infectiontime<-rep(Inf,N)#
#
#calculate distances between houses#
distance<-matrix(NA,nrow=N,ncol=N)#
for (i in 1:N){#
  for (j in 1:N){#
    distance[i,j]=sqrt((dataset$X[i]-dataset$X[j])^2+(dataset$Y[i]-dataset$Y[j])^2)#
  }#
}#
check3<- rep(Inf,N) #initialize data vector#
T_b <- 30 #threshold for bug infectiousness#
jumpprob <- .01 #probability of jump vs. hop#
bugs <- matrix(0,nrow=N,ncol=maxt) #initialize but matrix#
maxbugs <- max(sum.insp) #find most observed bugs in data#
initialinfective <- which(sum.insp==maxbugs) #set this house as initialinfective#
id=1:N #generate ids#
K=1000 #carrying capacity#
tuning <- 0.01 #tuning parameter for RJ#
#
#option1: define threshold as block#
#
#first fill in NAs#
#dataset$polygon[128]=191#
#dataset$polygon[129]=191#
#dataset$polygon[131]=191#
#dataset$polygon[139]=195#
#dataset$polygon[160]=256#
#dataset$polygon[191]=255#
#
#threshold1<-matrix(0,nrow=N,ncol=N)#
#for(i in 1:N){#
#  for(j in 1:N){#
#    threshold1[i,j] <- ifelse(dataset$polygon[i]==i.v.gps$polygon[j], 1 , jumpprob)#
#  }#
#}#
#option2: define threshold by radius of T_b#
#probability of infestation differs by hops (<T_b m) or jumps (>T_b m)#
threshold2 <- ifelse(distance<T_b, 1 , jumpprob)#
#decide which one you are using; this is what to change#
threshold <- threshold2#
#threshold <- threshold1
ls()
T_b
threshold2
threshold
ls()
maxbugs
vig
head(vig)
lat
plot(lat,long,data=vig)
plot(vig$lat,vig$long)
head(vig)
plot(vig$X,vig$Y)
ls()
thresholdblocks<-matrix(0,nrow=N,ncol=N)#
for(i in 1:N){#
  for(j in 1:N){#
    thresholdblocks[i,j] <- ifelse(dataset$uniblock[i]==dataset$uniblock[j], 1 , lambda)#
  }#
}#
#
threshold1<-matrix(0,nrow=N,ncol=N)#
for(i in 1:N){#
  for(j in 1:N){#
    threshold1[i,j] <- thresholdblocks[i,j]*exp(-distance[i,j]/delta)#
  }#
}
head(priors)
head(dataset)
dataset$sum.insp
head(dataset)
sum.insp
plot(dataset$X,dataset$Y,cex=10*dataset$predicteddensity)
points(dataset$X,dataset$Y,cex=10*sum.insp,col="red")
points(dataset$X,dataset$Y,cex=sum.insp,col="red")
points(dataset$X,dataset$Y,cex=log(sum.insp+1),col="red")
plot(dataset$X,dataset$Y,cex=10*dataset$predicteddensity)
points(dataset$X,dataset$Y,cex=log(sum.insp+1),col="red")
points(dataset$X,dataset$Y,cex=log(sum.insp+1),col="red",pch=19)
head(dataset)
setwd(~/Jewell/Results_Aug21/)#
#
Results2<- read.csv("Results2Aug21.csv")#
Results21<- read.csv("Results21Aug21.csv")#
Results22<- read.csv("Results22Aug21.csv")#
Results23<- read.csv("Results23Aug21.csv")
dir()
setwd("~/Jewell/Results_Aug21/")
Results2<- read.csv("Results2Aug21.csv")#
Results21<- read.csv("Results21Aug21.csv")#
Results22<- read.csv("Results22Aug21.csv")#
Results23<- read.csv("Results23Aug21.csv")#
#
#set whichever dataset you want to plot as Results1#
Results1 <- Results23#
colfunc = gray.colors(length(unique(Results1[,3])),start=1,end=0)[as.factor(Results1[,3])]#
plot(Results1[,4], Results1[,5],col = colfunc,pch=16,cex=.8)
head(Results23)
tail(Results23)
sel<-which()
points(dataset$X,dataset$Y,cex=10*sum.insp,col="red")
Results2<- read.csv("Results2Aug21.csv")#
Results21<- read.csv("Results21Aug21.csv")#
Results22<- read.csv("Results22Aug21.csv")#
Results23<- read.csv("Results23Aug21.csv")#
#
#set whichever dataset you want to plot as Results1#
Results1 <- Results23#
colfunc = gray.colors(length(unique(Results1[,3])),start=1,end=0)[as.factor(Results1[,3])]#
plot(Results1[,4], Results1[,5],col = colfunc,pch=16,cex=.8)
points(dataset$X,dataset$Y,cex=log(sum.insp+1),col="red")
plot(dataset$X,dataset$Y,cex=10*dataset$predicteddensity)#
points(dataset$X,dataset$Y,cex=log(sum.insp+1),col="red",pch=19)
setwd("~/Jewell/Results_Aug21/")#
#
Results2<- read.csv("Results2Aug21.csv")
Results1 <- Results2#
colfunc = gray.colors(length(unique(Results1[,3])),start=1,end=0)[as.factor(Results1[,3])]#
points(Results1[,4], Results1[,5],col = colfunc,pch=16,cex=.8)
points(dataset$X,dataset$Y,cex=log(sum.insp+1),col="red",pch=19)
plot(dataset$X,dataset$Y,cex=10*dataset$predicteddensity)
points(Results1[,4], Results1[,5],col = colfunc,pch=16,cex=.8)
plot(dataset$X,dataset$Y,cex=10*dataset$predicteddensity)
points(Results1[,4], Results1[,5],col = colfunc,pch=16,cex=.8)
plot(dataset$X,dataset$Y,cex=10*dataset$predicteddensity)
points(dataset$X,dataset$Y,cex=log(sum.insp+1),col="red")
points(Results1[,4], Results1[,5],col = colfunc,pch=16,cex=.8)
points(dataset$X,dataset$Y,cex=log(sum.insp+1),col="red",pch-16)
points(dataset$X,dataset$Y,cex=log(sum.insp+1),col="red",pch=16)
plot(dataset$X,dataset$Y,cex=15*dataset$predicteddensity)
points(dataset$X,dataset$Y,cex=log(sum.insp+1),col="red",pch=16)
plot(dataset$X,dataset$Y,cex=15*dataset$predicteddensity)
points(dataset$X,dataset$Y,cex=log(sum.insp+1),col="red",pch=16)
points(Results1[,4], Results1[,5])
points(Results1[,4], Results1[,5],col = colfunc,pch=16,cex=.8)
plot(dataset$X,dataset$Y,cex=15*dataset$predicteddensity)#
points(dataset$X,dataset$Y,cex=log(sum.insp+1),col="red",pch=16)
points(dataset$X,dataset$Y,cex=log(sum.insp+1),col="red",pch=16)
points(dataset$X,dataset$Y,cex=log(sum.insp+1),col="red",pch=16)
points(Results1[,4], Results1[,5],col = colfunc,pch=16,cex=.8)
points(Results1[,4], Results1[,5],col = colfunc,pch=16,cex=1.5)
points(dataset$X,dataset$Y,pch="x")
plot(dataset$X,dataset$Y,cex=15*dataset$predicteddensity)#
points(dataset$X,dataset$Y,cex=log(sum.insp+1),col="red",pch=16)#
#
points(Results1[,4], Results1[,5],col = colfunc,pch=16,cex=1.5)
colfun
colfunc
Results1[,3])
Results1[,3]
exp(Results1[,3]
)
exp(Results1[,3]*10
)
exp(Results1[,3]*10)
exp(Results1[,3])*10
colfunc
which(colfunc==#FFFFFF)
)
which(colfunc==""#FFFFFF")
)
which(colfunc==""#FFFFFF"))
which(colfunc=="#FFFFFF"))
which(colfunc=="#FFFFFF")
which(colfunc=="#FFFFFF")
olfunc = gray.colors(length(unique(Results1[,3])),start=1,end=0)[as.factor(Results1[,3])]#
colfunc[which(colfunc=="#FFFFFF")]<-"red"#
#
plot(dataset$X,dataset$Y,cex=15*dataset$predicteddensity)#
points(dataset$X,dataset$Y,cex=log(sum.insp+1),col="red",pch=16)
points(Results1[,4], Results1[,5],col = colfunc,pch=16,cex=1.2)
colfunc = gray.colors(length(unique(Results1[,3])),start=1,end=0)[as.factor(Results1[,3])]#
colfunc[which(sum.insp>=1]<-"red"#
#
plot(dataset$X,dataset$Y,cex=15*dataset$predicteddensity)#
points(dataset$X,dataset$Y,cex=log(sum.insp+1),col="red",pch=16)#
#
points(Results1[,4], Results1[,5],col = colfunc,pch=16,cex=1.2)
colfunc
plot(dataset$X,dataset$Y,cex=15*dataset$predicteddensity)
points(dataset$X,dataset$Y,cex=log(sum.insp+1),col="red",pch=16)
points(Results1[,4], Results1[,5],col = colfunc,pch=16,cex=1.2)
plot(dataset$X,dataset$Y,cex=15*dataset$predicteddensity)
points(dataset$X,dataset$Y,cex=log(sum.insp+1),col="red",pch=16)
points(Results1[,4], Results1[,5],col = colfunc,pch=16,cex=1.2)
points(dataset$X[sum.insp>=1],dataset$Y[sum.insp>=1], pch="x",col="black")
plot(Results1[,4], Results1[,5],col = colfunc,pch=16,cex=1.2)#
points(dataset$X[sum.insp>=1],dataset$Y[sum.insp>=1], pch="x",col="black")
Results1 <- Results23#
colfunc = gray.colors(length(unique(Results1[,3])),start=1,end=0)[as.factor(Results1[,3])]
#plot posteriors#
plot(Results1[,4], Results1[,5],col = colfunc,pch=16,cex=1.2)#
points(dataset$X[sum.insp>=1],dataset$Y[sum.insp>=1], pch="x",col="black")
Results1 <- Results2#
colfunc = gray.colors(length(unique(Results1[,3])),start=1,end=0)[as.factor(Results1[,3])]
plot(Results1[,4], Results1[,5],col = colfunc,pch=16,cex=1.2)#
points(dataset$X[sum.insp>=1],dataset$Y[sum.insp>=1], pch="x",col="black")
Results1 <- Results22#
colfunc = gray.colors(length(unique(Results1[,3])),start=1,end=0)[as.factor(Results1[,3])]
#plot posteriors#
plot(Results1[,4], Results1[,5],col = colfunc,pch=16,cex=1.2)#
points(dataset$X[sum.insp>=1],dataset$Y[sum.insp>=1], pch="x",col="black")
Results1 <- Results21#
colfunc = gray.colors(length(unique(Results1[,3])),start=1,end=0)[as.factor(Results1[,3])]
#plot posteriors#
plot(Results1[,4], Results1[,5],col = colfunc,pch=16,cex=1.2)#
points(dataset$X[sum.insp>=1],dataset$Y[sum.insp>=1], pch="x",col="black")
Results1 <- Results22#
colfunc = gray.colors(length(unique(Results1[,3])),start=1,end=0)[as.factor(Results1[,3])]
#plot posteriors#
plot(Results1[,4], Results1[,5],col = colfunc,pch=16,cex=1.2)#
points(dataset$X[sum.insp>=1],dataset$Y[sum.insp>=1], pch="x",col="black")
Results1 <- Results21#
colfunc = gray.colors(length(unique(Results1[,3])),start=1,end=0)[as.factor(Results1[,3])]
#plot posteriors#
plot(Results1[,4], Results1[,5],col = colfunc,pch=16,cex=1.2)#
points(dataset$X[sum.insp>=1],dataset$Y[sum.insp>=1], pch="x",col="black")
